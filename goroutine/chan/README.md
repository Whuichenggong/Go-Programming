代码能够通过编译，但是执行的时候会出现以下错误：

```go
func main() {
	ch := make(chan int)
	ch <- 10
	fmt.Println("发送成功")
}
```

```shell
go run main.go
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
        E:/Go-Programming/goroutine/chan/main.go:7 +0x28
exit status 2
```

，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。

如何理解 ch <- 10 发送数据？
实际上，ch <- 10 是向通道 ch 发送数据，但如果没有接收方准备好接收数据，这个操作会阻塞，直到接收方准备好。默认情况下，在同一个 goroutine 中，如果没有其他 goroutine 在接收数据，发送操作会被阻塞。

##  无缓冲通道 (Unbuffered Channel)

无缓冲通道是最简单的一种通道，它没有内部缓冲区，数据的发送和接收是同步的。在使用无缓冲通道时，发送操作会被阻塞，直到另一个 goroutine 执行接收操作，接收操作也会被阻塞，直到有数据可供接收。

### 优点：

1. 同步通信：
无缓冲通道能够保证发送和接收的操作是同步的，即发送方和接收方必须同时存在，协程间可以通过无缓冲通道进行紧密的协作。这对于需要保证发送方和接收方按顺序、按节奏进行处理的场景非常有用。

2. 简洁性：
无缓冲通道的使用非常直接，容易理解。它的行为非常简单，能够让并发程序中的数据传递变得清晰明了。

## 有缓冲通道(Buffered Channel)

### 优点：

1. 异步操作：
有缓冲通道使得发送操作和接收操作可以异步进行，发送方不需要等待接收方立即处理数据，能够提高程序的并发性能和吞吐量。

2. 减少阻塞：
由于有缓冲区，可以缓存一定数量的数据，发送方和接收方不必总是同时准备好处理数据，减少了阻塞和等待的时间。

3. 灵活性：
通过缓冲通道，开发者可以控制缓冲区大小，根据实际需求进行性能调优。

